
import HealthKit
import NitroModules

// Assume 'store' is a global HKHealthStore instance, initialized in Auth.swift
// Assume helper functions like quantityTypeFromString, categoryTypeFromString, objectTypeFromString,
// and mapMetadataToSwift (from AnyMapHolder) are available globally or in a shared 'Helpers.swift'.

// Placeholder for what Nitro would generate from your TypeScript specs.
// You'd have actual struct definitions for QuantitySampleForSaving, CategorySampleForSaving etc.
public protocol HybridSamplesSpec: AnyObject {
    func saveQuantitySample(
        typeIdentifier: String,
        value: Double,
        unitString: String,
        startTimestamp: Double,
        endTimestamp: Double,
        metadata: AnyMapHolder?
    ) throws -> Promise<String?>

    func saveCategorySample(
        typeIdentifier: String,
        value: Double, // For HKCategorySample, 'value' usually corresponds to an enum rawValue
        startTimestamp: Double,
        endTimestamp: Double,
        metadata: AnyMapHolder?
    ) throws -> Promise<String?>

    // Deletes a single sample by its UUID.
    // The 'typeIdentifier' is needed to construct the HKObjectType for deletion.
    func deleteSample(typeIdentifier: String, uuidString: String) throws -> Promise<Bool>

    // Deletes all samples of a given type within a date range.
    func deleteSamplesOfType(typeIdentifier: String, startTimestamp: Double, endTimestamp: Double) throws -> Promise<Bool>
}

class Samples: HybridSamplesSpec {

    func saveQuantitySample(
        typeIdentifier: String,
        value: Double,
        unitString: String,
        startTimestamp: Double,
        endTimestamp: Double,
        metadata: AnyMapHolder?
    ) throws -> Promise<String?> {
        guard let quantityType = quantityTypeFromString(typeIdentifier) else {
            throw RuntimeError.error(withMessage: "Invalid quantity type identifier: \(typeIdentifier)")
        }

        let unit = HKUnit(from: unitString)
        let quantity = HKQuantity(unit: unit, doubleValue: value)
        let startDate = Date(timeIntervalSince1970: startTimestamp)
        let endDate = Date(timeIntervalSince1970: endTimestamp)
        let swiftMetadata = mapMetadataToSwift(metadata)

        let quantitySample = HKQuantitySample(
            type: quantityType,
            quantity: quantity,
            start: startDate,
            end: endDate,
            metadata: swiftMetadata
        )

        return Promise.async {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<String?, Error>) in
                store.save(quantitySample) { success, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else if success {
                        continuation.resume(returning: quantitySample.uuid.uuidString)
                    } else {
                        continuation.resume(returning: nil) // Or throw an error if success is false but no error is present
                    }
                }
            }
        }
    }

    func saveCategorySample(
        typeIdentifier: String,
        value: Double, // This will be cast to Int for HKCategorySample value
        startTimestamp: Double,
        endTimestamp: Double,
        metadata: AnyMapHolder?
    ) throws -> Promise<String?> {
        guard let categoryType = categoryTypeFromString(typeIdentifier) else {
            throw RuntimeError.error(withMessage: "Invalid category type identifier: \(typeIdentifier)")
        }

        let startDate = Date(timeIntervalSince1970: startTimestamp)
        let endDate = Date(timeIntervalSince1970: endTimestamp)
        let intValue = Int(value) // HKCategorySample values are Int
        let swiftMetadata = mapMetadataToSwift(metadata)

        let categorySample = HKCategorySample(
            type: categoryType,
            value: intValue,
            start: startDate,
            end: endDate,
            metadata: swiftMetadata
        )

        return Promise.async {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<String?, Error>) in
                store.save(categorySample) { success, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else if success {
                        continuation.resume(returning: categorySample.uuid.uuidString)
                    } else {
                        continuation.resume(returning: nil)
                    }
                }
            }
        }
    }

    func deleteSample(typeIdentifier: String, uuidString: String) throws -> Promise<Bool> {
        guard let objectType = objectTypeFromString(typeIdentifier: typeIdentifier) else {
            throw RuntimeError.error(withMessage: "Invalid object type identifier for deletion: \(typeIdentifier)")
        }
        guard let uuid = UUID(uuidString: uuidString) else {
            throw RuntimeError.error(withMessage: "Invalid UUID string for deletion: \(uuidString)")
        }

        // First, query for the specific sample to ensure it exists and matches the type.
        // This step is optional but recommended to avoid errors if the object doesn't exist
        // or if trying to delete an object of a different type than expected.
        // For simplicity here, we'll proceed to delete directly.
        // HKHealthStore.delete(_ object: HKObject, withCompletion completion: @escaping (Bool, Error?) -> Void)
        // However, creating a dummy object with only UUID and type for deletion is not directly supported.
        // The common way is to fetch the object first, then delete it.
        // Or use deleteObjects(of:predicate:withCompletion:)

        let predicate = HKQuery.predicateForObject(with: uuid)

        return Promise.async {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Bool, Error>) in
                store.deleteObjects(of: objectType, predicate: predicate) { success, count, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        // 'success' here indicates the operation was attempted.
                        // 'count' tells how many objects were deleted.
                        // We can consider it successful if no error and count > 0, or just rely on success.
                        continuation.resume(returning: success && count > 0)
                    }
                }
            }
        }
    }

    func deleteSamplesOfType(typeIdentifier: String, startTimestamp: Double, endTimestamp: Double) throws -> Promise<Bool> {
        guard let objectType = objectTypeFromString(typeIdentifier: typeIdentifier) else {
            throw RuntimeError.error(withMessage: "Invalid object type identifier for batch deletion: \(typeIdentifier)")
        }

        let startDate = Date(timeIntervalSince1970: startTimestamp)
        let endDate = Date(timeIntervalSince1970: endTimestamp)
        let predicate = HKQuery.predicateForSamples(withStart: startDate, end: endDate, options: .strictStartDate)

        return Promise.async {
            try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Bool, Error>) in
                store.deleteObjects(of: objectType, predicate: predicate) { success, count, error in
                    if let error = error {
                        continuation.resume(throwing: error)
                    } else {
                        // 'success' indicates the operation was attempted.
                        // We can define success as no error occurring.
                        continuation.resume(returning: success)
                    }
                }
            }
        }
    }
}

// Dummy helper function placeholders - these should exist in your actual Helpers.swift or similar
// and be properly implemented.
private func quantityTypeFromString(_ id: String) -> HKQuantityType? {
    return HKQuantityType.quantityType(forIdentifier: HKQuantityTypeIdentifier(rawValue: id))
}

private func categoryTypeFromString(_ id: String) -> HKCategoryType? {
    return HKCategoryType.categoryType(forIdentifier: HKCategoryTypeIdentifier(rawValue: id))
}

// This is used by Auth.swift as well.
internal func objectTypeFromString(typeIdentifier: String) -> HKObjectType? {
    if let quantityType = HKQuantityType.quantityType(forIdentifier: HKQuantityTypeIdentifier(rawValue: typeIdentifier)) {
        return quantityType
    }
    if let categoryType = HKCategoryType.categoryType(forIdentifier: HKCategoryTypeIdentifier(rawValue: typeIdentifier)) {
        return categoryType
    }
    if let characteristicType = HKCharacteristicType.characteristicType(forIdentifier: HKCharacteristicTypeIdentifier(rawValue: typeIdentifier)) {
        return characteristicType
    }
    if typeIdentifier == HKWorkoutTypeIdentifier { // HKWorkoutType.workoutType().identifier is not a thing
        return HKWorkoutType.workoutType()
    }
    if #available(iOS 10.0, *), typeIdentifier == HKDocumentTypeIdentifier.cda.rawValue {
         return HKDocumentType.documentType(forIdentifier: HKDocumentTypeIdentifier.cda)
    }
    // Add other types as needed (Correlations, etc.)
    if #available(iOS 11.0, *), typeIdentifier == HKWorkoutRouteTypeIdentifier {
        return HKSeriesType.workoutRoute()
    }
    // ... and other series types like heartbeat series if needed.

    print("Warning: Unhandled type identifier in objectTypeFromString: \(typeIdentifier)")
    return nil
}


private func mapMetadataToSwift(_ metadata: AnyMapHolder?) -> [String: Any]? {
    // Actual implementation would convert AnyMapHolder to [String: Any]
    // For now, returning nil or an empty dictionary.
    // This depends on how AnyMapHolder is defined and used by Nitro.
    guard let metadata = metadata else { return nil }
    // Assuming AnyMapHolder has a way to get a Swift dictionary
    // e.g., return metadata.dictionaryValue
    // This is a simplified placeholder:
    var swiftMeta: [String: Any] = [:]
    // You'd iterate through metadata if it's a custom Nitro type
    // and populate swiftMeta.
    // If AnyMapHolder IS [String: Any] or similar via typealias from Nitro,
    // then this function might just be a cast or direct use.
    // For this example, let's assume it's a dictionary itself if not nil.
    // This part is highly dependent on Nitro's actual generated types.
    // If AnyMapHolder is a class/struct wrapping a dictionary:
    // return metadata.dictionary
    // If it's a typealias for [String: AnyCodable], you'd process it.
    // For now, let's assume it's not directly usable and needs conversion,
    // or Nitro handles it. If it's directly usable, this function is simpler.
    // This is a common pattern if AnyMapHolder is just a typealias for [String: Any]
    // return metadata as? [String: Any]
    
    // Given the usage in Workout.swift:
    // func saveWorkoutSample(..., metadata: AnyMapHolder)
    // let swiftMetadata = nitroMapToSwift(metadata)
    // It implies nitroMapToSwift is a global helper.
    // Let's assume a simple conversion for now if it's a dictionary like structure.
    // This is a placeholder and needs to match your actual Nitro setup.
    // If AnyMapHolder is a struct with a 'value' property that is [String: Any]
    // return metadata.value
    return nil // Placeholder: Replace with actual conversion logic based on AnyMapHolder
}
